#!/usr/bin/env node
/**
 * Whitelist Watcher
 * Polls GitHub Gist and writes UserIDs.lua for Rojo sync
 * 
 * Usage: node whitelist-watcher.js
 * 
 * Environment:
 *   GIST_ID - Your GitHub Gist ID
 *   OUTPUT_PATH - Path to write UserIDs.lua (default: ./src/server/UserIDs.lua)
 *   POLL_INTERVAL - Seconds between checks (default: 30)
 */

'use strict';

const https = require('https');
const fs = require('fs');
const path = require('path');
const crypto = require('crypto');

const GIST_ID = process.env.GIST_ID;
const OUTPUT_PATH = process.env.OUTPUT_PATH || './src/server/UserIDs.lua';
const POLL_INTERVAL = parseInt(process.env.POLL_INTERVAL, 10) || 30;

if (!GIST_ID) {
    console.error('Error: GIST_ID environment variable required');
    console.error('Usage: GIST_ID=your_gist_id node whitelist-watcher.js');
    process.exit(1);
}

const GIST_URL = `https://gist.githubusercontent.com/raw/${GIST_ID}/whitelist.json`;

let lastHash = null;

function log(msg) {
    console.log(`[${new Date().toISOString()}] ${msg}`);
}

function fetchGist() {
    return new Promise((resolve, reject) => {
        const url = `${GIST_URL}?t=${Date.now()}`;
        https.get(url, { headers: { 'User-Agent': 'WhitelistWatcher' } }, res => {
            if (res.statusCode !== 200) {
                reject(new Error(`HTTP ${res.statusCode}`));
                return;
            }
            let data = '';
            res.on('data', chunk => data += chunk);
            res.on('end', () => {
                try {
                    resolve(JSON.parse(data));
                } catch (e) {
                    reject(new Error('Invalid JSON'));
                }
            });
        }).on('error', reject);
    });
}

function generateLua(whitelist) {
    const lines = ['-- Auto-generated by whitelist-watcher.js', '-- Do not edit manually', '', 'local UserIDs = {'];
    
    const sortedIds = Object.keys(whitelist).sort((a, b) => parseInt(a) - parseInt(b));
    
    for (const id of sortedIds) {
        const entry = whitelist[id];
        const guns = (entry.guns || []).map(g => `"${g}"`).join(', ');
        const name = entry.name || 'unknown';
        lines.push(`\t[${id}] = {${guns}}, --${name}`);
    }
    
    lines.push('}');
    lines.push('');
    lines.push('return UserIDs');
    
    return lines.join('\n');
}

function hashContent(content) {
    return crypto.createHash('md5').update(content).digest('hex');
}

async function sync() {
    try {
        const whitelist = await fetchGist();
        const lua = generateLua(whitelist);
        const hash = hashContent(lua);
        
        if (hash === lastHash) {
            return false; // No changes
        }
        
        // Ensure directory exists
        const dir = path.dirname(OUTPUT_PATH);
        if (!fs.existsSync(dir)) {
            fs.mkdirSync(dir, { recursive: true });
        }
        
        fs.writeFileSync(OUTPUT_PATH, lua, 'utf8');
        lastHash = hash;
        
        const count = Object.keys(whitelist).length;
        log(`✅ Updated ${OUTPUT_PATH} (${count} entries)`);
        return true;
    } catch (e) {
        log(`❌ Sync failed: ${e.message}`);
        return false;
    }
}

async function watch() {
    log(`Watching Gist ${GIST_ID}`);
    log(`Output: ${path.resolve(OUTPUT_PATH)}`);
    log(`Poll interval: ${POLL_INTERVAL}s`);
    log('');
    
    // Initial sync
    await sync();
    
    // Poll loop
    setInterval(sync, POLL_INTERVAL * 1000);
}

// Handle graceful shutdown
process.on('SIGINT', () => {
    log('Stopping watcher...');
    process.exit(0);
});

watch();
